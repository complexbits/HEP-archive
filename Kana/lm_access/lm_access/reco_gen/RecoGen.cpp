/////////////////////////////////////////////////////////////////////////////
//               Name       : RecoGen.cpp                                  //
//               Created by : Prolay Kumar Mal                             //
//               Purpose    : To count min_bias and zero_bias              //
//                            events in a Root-tuple for generating        //
//                            Stage2 Luminosity files and tallies with     //
//                            SAM database information.                    //
//               Date       : April 15, 2002                               //
//               Input      : info.txt (generated by Python script         //
//                            after making SQL query to SAM                //
//                            and also uses the ReadSAMinfo.hpp            //
//               Output     : reco_out.txt (in the preferred python        //
//                            dictionary format by Michael) and            //
//                            error_out.txt for errors                     //
//       This code is written based on the suggestions made by             //
//                   Marcos Verzocchi                                      //
//             Many many thanks to Alexander Kupco                         //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////
#include <ReadSAMinfo.hpp>
#include <iostream>
#include <fstream>
#include <string>
#include <map>
#include <TROOT.h>
#include <TBranch.h>
#include <TFile.h>
#include <TLeaf.h>
#include <TTree.h>
using namespace std;

int main(int argc, char* argv[]){
  //Definitions of the Maps:
  map<int,string> MBL3NM;//Minimum bias L3 trigger bit name
  map<int,string> ZBL3NM;//Zero bias L3 trigger bit name
  map<int,int> MBL1Num; //Number of MB triggers fired at L1
  map<int,int> MBL3Num; //Number of MB triggers fired at L3
  map<int,int> ZBL1Num; //Number of ZB triggers fired at L1
  map<int,int> ZBL3Num; //Number of ZB triggers fired at L3
  map<int,int> MBL1TBN; //MB L1 trigger Bit Number
  map<int,int> ZBL1TBN; //ZB L1 trigger Bit Number
  map<int,string> RootTuple; //Name of the file being processed
  map<int,string> RecoVersion; //Version of the reco
  map<int,string> DataStream;  //Data Stream Name
  //Error maps:
  //std::map<int,string> Errstring ;// Make a note of the faulty LBN
  
  //Creating the class ReadInfo
  //Reading the output of SQLquery:
  const char * filename= "info.txt";
  //No of files to be processed:
  const int noffile=1;
  ReadInfo Information(filename, noffile);
  // output file name
  char* outputfile = "reco_out.txt";
  char* errorfile="error_out.txt";
  ofstream ferr(errorfile,ios::app);
  //FILE* ferr=fopen(errorfile, "a+w");
  string mstring="min_bias";
  string zstring="zero_bias";
  int lastLBN=-1;
  //Indices for LBN_MAX & LBN_MIN:
  int LBNMIN=100000000;
  int LBNMAX=-2;

  // loop over the root tuple files & 
  for(int i_file = 1; i_file < argc;  i_file++) {
    // open root-tuple file
    TFile f(argv[i_file], "READ");
    TTree& data = *((TTree*) f.Get("Global"));
    data.SetBranchStatus("*", 0);
    data.SetBranchStatus("EVENT", 1);
    
    /* Event branch */
    TBranch *Event = data.GetBranch("EVENT");
    
    int runnum;
    TLeaf* L_runnum = Event->GetLeaf("runnum");
    L_runnum->SetAddress(&runnum);
    
    TLeaf* L_L3bits = Event->GetLeaf("L3bits");
    int* L3bits = new int[L_L3bits->GetNdata()];
    int nL3bits = L_L3bits->GetNdata();
    L_L3bits->SetAddress(L3bits);
    
    int LumBlk;
    TLeaf* L_lumblk = Event->GetLeaf("lumblk");
    L_lumblk->SetAddress(&LumBlk);
    
    // for L3trigger name
    TLeaf* L_L3names = Event->GetLeaf("L3names");
    int* L3names = new int[L_L3names->GetNdata()];
    L_L3names->SetAddress(L3names);
    
    std::string fname = argv[i_file];
    fname.erase(0,fname.find("recoA"));
    std::string fvers = fname;
    fvers.erase(0,fvers.find("p10"));
    fvers.replace(9,5,"");

    
    /* find out number of events in file */
    Stat_t nEnt = data.GetEntries();
    cout<<"           Events in the ROOT tuple: "<<nEnt<<"\traw data events: "<<Information._rawnofevnt[fname]<<endl;
    if (nEnt != Information._rawnofevnt[fname])
      ferr<<fname<<" : Number of events does't match with the tuple events; Ntuple: "<<nEnt<<"  Nraw : "<<Information._rawnofevnt[fname]<<endl;
    // get number of events
    //cout << "Number of entries: " << nEnt << endl << flush;
    if (nEnt < 0) {
      cerr << "File " << fname << " does not contain any event" << endl;
    } else {
      /* loop over the events */
      for(int i = 0; i < nEnt; i++) {
	data.GetEntry(i);
	//Handling a new LBN
	if ( LumBlk !=lastLBN) {
	  lastLBN = LumBlk;
	  if(!Information.ReadLBN(lastLBN))
	    ferr<<lastLBN<<" : "<<fname<<" contains LBN "<<lastLBN<<" ;but SAM doesn't show up the LBN"<<"\n";
	  if(lastLBN<LBNMIN)LBNMIN=lastLBN;
	  if(lastLBN>LBNMAX)LBNMAX=lastLBN;
	  // Intialize all the maps
	  map<int,int>::iterator m1;
	  m1 = MBL1Num.find(lastLBN);
	  if ( m1 == MBL1Num.end() ) MBL1Num.insert(std::pair<int,int>(lastLBN,0));
	  map<int,int>::iterator m3;
	  m3 = MBL3Num.find(lastLBN);
	  if ( m3 == MBL3Num.end() ) MBL3Num.insert(std::pair<int,int>(lastLBN,0));
	  map<int,int>::iterator z1;
	  z1 = ZBL1Num.find(lastLBN);
	  if ( z1 == ZBL1Num.end() ) ZBL1Num.insert(std::pair<int,int>(lastLBN,0));
	  map<int,int>::iterator z3;
	  m3 = ZBL3Num.find(lastLBN);
	  if ( z3 == ZBL3Num.end() ) ZBL3Num.insert(std::pair<int,int>(lastLBN,0));
	  map<int,int>::iterator ztbn;
	  ztbn = ZBL1TBN.find(lastLBN);
	  if ( ztbn == ZBL1TBN.end() ) ZBL1TBN.insert(std::pair<int,int>(lastLBN,Information._l1bitzero[lastLBN]));
	  map<int,int>::iterator mtbn;
	  mtbn = MBL1TBN.find(lastLBN);
	  if ( mtbn == MBL1TBN.end() ) MBL1TBN.insert(std::pair<int,int>(lastLBN,Information._l1bitmin[lastLBN]));
	  map<int,string>::iterator mtn;
	  mtn = MBL3NM.find(lastLBN);
	  if ( mtn == MBL3NM.end() ) MBL3NM.insert(std::pair<int,string>(lastLBN,mstring));
	  map<int,string>::iterator ztn;
	  ztn = ZBL3NM.find(lastLBN);
	  if ( ztn == ZBL3NM.end() ) ZBL3NM.insert(std::pair<int,string>(lastLBN,zstring));
	  map<int,string>::iterator name;
	  name = RootTuple.find(lastLBN);
	  if ( name == RootTuple.end() ) RootTuple.insert(std::pair<int,string>(lastLBN,fname));
	  map<int,string>::iterator vsn;
	  vsn = RecoVersion.find(lastLBN);
	  if ( vsn == RecoVersion.end() ) RecoVersion.insert(std::pair<int,string>(lastLBN,fvers));
	  map<int,string>::iterator ds;
	  ds = DataStream.find(lastLBN);
	  if ( ds == DataStream.end() ) DataStream.insert(std::pair<int,string>(lastLBN,Information._datastream[lastLBN]));
	} // Processing a new LBN
	
	// ----------------------------------------------------------
	// for finding L3trigger name (Suyong)
	Bool_t TrigMinBias = kFALSE;
	Bool_t TrigZroBias = kFALSE;
	for ( Int_t l3bitnum = 0 ; l3bitnum != nL3bits ; ++l3bitnum ) {
	  if ( L3bits[l3bitnum] == 1 ) {
	    Bool_t endOfName = kFALSE;
	    char l3TrigName[32];
	    l3TrigName[0] = '\0';
	    // The trigger name is stored in an array of integers
	    for ( Int_t ichar = 0; !endOfName && ichar != 32 ;  ++ichar ) {
	      Int_t arrayindex = l3bitnum*32+ichar;
	      char thischar = (char) L3names[arrayindex];
	      l3TrigName[ichar] = thischar;
	      if ( thischar == '\0' ) endOfName = kTRUE;
	    } // End decoding loop for L3 trigger name
	    
	    // Search for the minimum bias and zero bias triggers
	    if ( !strcmp("min_bias",l3TrigName) )  TrigMinBias = kTRUE;
	    if ( !strcmp("zero_bias",l3TrigName) ) TrigZroBias = kTRUE;
	    
	  } // End test on a single L3 trigger bit
	} // End loop on L3 trigger bits
	// ----------------------------------------------------------
	
	// find min_bias evevnt and setL1bit and incresing +1 events.
	if ( TrigMinBias ) {
	  ++MBL1Num[lastLBN];
	  ++MBL3Num[lastLBN];
	}
	if ( TrigZroBias ) {
	  ++ZBL1Num[lastLBN];
	  ++ZBL3Num[lastLBN];
	}
	//Checking the inconsistency in run number
	if(runnum!=Information._runnumb[lastLBN])
	  ferr<<runnum<<" :Run Number doesn't match for LBN: "<<lastLBN<<"\t"<<",Event number: "<<i<<"\t"<<"Filename : "<<fname<<endl; 
      }//Loop over the events ends
    }
    f.Close();
  }//Loop over the files ends
  ferr.close();//Closing the errorlog file
  //Appending  into the output file 
  ofstream fout(outputfile,ios::app);
  for(map<int, string>::const_iterator l=RootTuple.begin();l!=RootTuple.end();++l){
    int j1=l->first;
    //cout<<j1<<"\t"<<"RECO({ 'LBN' : "<<j1<<", '"<<MBL3NM[j1]<<"' : "<<MBL3Num[j1]<<", '"<<ZBL3NM[j1]<<"' : "<<ZBL3Num[j1]<<", "<<MBL1TBN[j1]<<" : "<<MBL1Num[j1]<<", "<<ZBL1TBN[j1]<<" : "<<ZBL1Num[j1]<<", 'File' : '"<<RootTuple[j1]<<", 'Version' : '"<<RecoVersion[j1]<<", 'Stream' : '"<<DataStream[j1]<<"' })"<<endl;
    fout<<"RECO({ 'LBN' : "<<j1<<", '"<<MBL3NM[j1]<<"' : "<<MBL3Num[j1]<<", '"<<ZBL3NM[j1]<<"' : "<<ZBL3Num[j1]<<", "<<MBL1TBN[j1]<<" : "<<MBL1Num[j1]<<", "<<ZBL1TBN[j1]<<" : "<<ZBL1Num[j1]<<", 'File' : '"<<RootTuple[j1]<<"', 'Version' : '"<<RecoVersion[j1]<<"', 'Stream' : '"<<DataStream[j1]<<"' })"<<endl;
  }
  fout.close();
  return 0;
}
